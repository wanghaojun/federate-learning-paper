## 微光：解决隐私和信任的泥潭

### 摘要

现在的用户可以访问大量依赖于用户贡献数据的服务，比如推荐服务、预测服务以及帮助分类和解释数据的服务。这些服务的质量不可避免地依赖于用户的可靠贡献。然而，验证贡献的可信度可能依赖于对用户隐私上下文数据，如用户的位置或使用习惯，创建一个隐私和信任之间的冲突：用户受益于一个高质量的服务，识别并删除非法用户的贡献，但与此同时，他们可能不愿让服务访问他们的私人信息以达到这么高的质量。

我们认为，这种冲突可以通过一种务实的信任来解决，这种信任允许服务以一种值得信任的方式验证用户的贡献，而不会丧失用户的隐私。我们描述了值得信赖的硬件，如英特尔的SGX可以在客户端上使用——与最近在云服务上探索SGX的工作形成对比——来实现微光架构，并演示了这种实现如何能够在各种情况下解决隐私和信任之间的紧张关系。

### 1 隐私与云服务

许多互联网服务收集用户提供的数据。然后，通过处理这些数据收集到的用户数据贡献和聚合通常会在服务的所有用户之间共享。例如，客户端设备上的预测键盘可以受益于使用来自不同用户键盘的输入（图1a）来进行训练的机器学习模型。随着时下的话题（比如“世界职业棒球大赛”或“唐纳德·特朗普”）上升——因为许多用户在很短的时间内就在键盘上键入这些词——当爱丽丝键入“唐纳德”时，最新的模型可以提示“特朗普”作为下一个单词，即使她自己从来没有键入过这个名字。类似的好处存在于广泛的应用程序中，如图像识别、推荐系统和活动检测。

<img src="C:\Users\Ree\Pictures\ScreenCapture\capture_20201121111826243.bmp" alt="capture_20201121111826243" style="zoom:50%;" />

可悲的是，**共享信息，尤其是诸如按键之类的深层个人信息，自然会在信息实用程序和用户隐私之间引发一场争斗**。如果Alice的键盘将她所有的按键都流到一个共享的、可预测的键盘服务上，她几乎肯定会泄露有关她的政治信仰的敏感信息。尽管Alice的单键点击对学习全球预测词模型有意义，但它们并不是公开信息，允许它们用于培训并不等于将它们发布到一个世界可读的网页上。然而，大多数服务提供商发布的信息很少（如果有的话），说明他们对所收集的数据做了什么，这可能会给既想提供帮助又关心隐私的用户带来麻烦。例如，Bob在图1a中的诋毁性言论可能使恶意服务提供商歧视他或协助起诉他。即使服务提供商是善意的，它也可能被法院命令向政府发布这些信息，以迫害Bob，被黑客窃取以勒索他或损害服务品牌，或被监管机构用来对服务提供商处以侵犯隐私罚款。因此，非中介信息共享对于用户和服务都是不可取的。

解这种矛盾的一种方法是**在客户端处理用户数据，这样就不会以原始的方式向服务披露数据**[12,16]。使用联邦机器学习[12]，每个客户端计算一个局部模型，服务将这些模型相加生成一个全局模型。例如，图1b中的一个简单键盘模型为一个有序的单词对关联了一个介于0和1之间的权重，而没有显示实际输入的句子。然而，学习过的模型，即使是比我们的稻草人插图复杂得多的模型，仍然可以揭示用于训练那些模型的原始输入的信息(例如，机器学习模型可以被倒置[6])。

<img src="C:\Users\Ree\Pictures\ScreenCapture\capture_20201121112658065.bmp" alt="capture_20201121112658065" style="zoom:50%;" />

因此，无论是否在客户端进行预处理，用户都应该减少服务可以访问的私人信息量。此外，请注意，许多服务不需要访问任何个人的贡献，而只需要访问大量用户的聚合；对于此类服务，接收和存储单个用户的私有数据会带来不必要的成本、风险和责任。因此，服务可以让用户使用**加密盲法**[4]（图1c）或类似的技术来提供信息，这些技术可以在隐藏所提供的单个数据项的同时精确地聚合数据集。

<img src="C:\Users\Ree\Pictures\ScreenCapture\capture_20201121112744687.bmp" alt="capture_20201121112744687" style="zoom:50%;" />

不幸的是，这种技术对服务隐藏了原始的输入，从而使**恶意用户有机会贡献不正当的输入**而不被发现，从而影响共享服务的质量。例如，Alice可以为她自己的键盘序列提供一个盲目的本地模型，该模型被恶意操纵，从而夸大了她的个人政治信念（即，为一个模型参数提供了一个非法值538，违反了[0，1]的有效方位），使它看起来非常受欢迎，超出了单个用户的范围。当服务将盲化的局部模型聚合在一起时，即使存在特定的验证检查(如范围检查)，也无法检测到这种诱导的偏差，因为存在盲化。结果，该服务的全球预测模型严重扭曲，导致预测不准，降低了所有用户的体验。

<img src="C:\Users\Ree\Pictures\ScreenCapture\capture_20201121113014481.bmp" alt="capture_20201121113014481" style="zoom:50%;" />

这样的攻击并不是无足轻重的，应该认真对待:改变预测的顺序可能会扭曲思维过程，正如[5]所显示的影响选举结果的搜索排名操纵。在我们的例子中，检查Alice贡献的明显方法是在失明发生之前，但是服务不能信任Alice忠实地这样做，因为她是该威胁中的对手。即使用户的实际贡献本身不是私有的，比如用户的照片与地图服务上的某个位置相关联，验证这些贡献可能需要该服务访问位于该用户设备上的私有数据（例如，通过GPS和环境WiFi的位置历史，以验证用户确实去了声称的位置），否则验证就意味着要保护该用户的恶意。

受这种信任-隐私权衡影响的服务具有类似的特征：a）它们使用用户贡献的数据来建立有利于所有用户的全局状态；b）服务质量高度依赖于用户贡献的数据的可信性；和c）只能通过直接访问敏感用户数据（贡献本身，或者上下文用户信息，如日志和其他用户活动）来验证用户贡献的合法性。许多流行的服务都具有这些属性。例如，图像识别可以从针对用户私人照片训练的局部模型中获益，但要验证贡献的照片是合法的，就需要在它们被盲掉之前直接访问它们;推荐服务通过个人用户注册的“喜欢”、“不喜欢”和购物习惯来学习产品之间的相似性，但检测虚假评论需要访问个人用户的购买历史记录;活动识别模型通过分析家庭摄像机拍摄的剪影和图像结构得到了改进，但检查剪影是否合法需要分析在人们家中拍摄的完整视频流。考虑到目前的情况，人们可能会遗憾地得出这样的结论:在这些服务中，信任和隐私是一个零和游戏——个人隐私的增加会直接导致所有用户对服务的信任程度的下降。在下一节中，我们将介绍走出这一困境的微光。

### 2 介于两者之间信任的微光

为了将隐私和信任之间的难题形象化，我们在客户端和服务之间引入了**信任边界**的概念；私有数据不应该从客户端跨到服务端，但是必须根据客户端的服务设置的标准来检查客户端贡献的正确性。服务器无法在不访问私有数据的情况下建立信任，但同时客户端也不希望服务器不受限制地访问其私有数据。

这样的“气隙”问题可以通过引入可信的第三方来解决，该第三方在将用户贡献提交给服务之前对私有客户端数据执行验证。我们将逻辑可信第三方称为Glimmer of  Trust(简称Glimmer)，因为它执行非常有限但基本的可信功能：验证由服务指定的私有数据，然后提交到服务(图2)。

<img src="C:\Users\Ree\AppData\Roaming\Typora\typora-user-images\1605931986151.png" alt="1605931986151" style="zoom:50%;" />

我们在这里松散地使用术语验证来捕获委托给可信第三方的任何有效性谓词；不同的验证谓词可能会牺牲计算复杂度来换取结果的准确性。例如，在下一个词预测服务中，距离检查模型参数确保Alice在期望值在0到1之间时不能发送用户贡献值538；但是，她仍然可以在该范围内发送任意虚构的值，这些值可能不符合她实际的键盘活动。**更复杂的验证器可能会观察实际的键盘行为**（类似于NAB[7]），以匹配键盘事件与报告的模型权重；或者甚至**观察CPU分支[20]来确定一个模型构建代码的合理执行**，该代码产生了部分结果，就像在线游戏作弊检测[3]所建议的那样。当更多的侵入性验证增加了微光所需要的复杂性和资源时，它也增加了对手欺骗而不被发现的成本，因为她现在必须伪造键盘活动或程序执行来证实她对服务的欺骗性输入。

不管实际的验证语义是什么，Glimmer必须满足某些属性才能有所帮助。首先，**它必须保证在处理后丢弃私有输入**，或者如果私有数据是贡献的一部分，它将遮蔽私有输入，从而限制泄漏的私有数据的信息量(输入机密性)。其次，**它只认可服务使用那些经过验证的贡献(输入完整性)**。

有一个实际的第三方来扮演微光的角色，可以说，是这个架构的实现。例如，电子前沿基金会（Electronic Frontier Foundation,  EFF）或隐私保护组织联盟可以集成地执行验证和盲检测，可能使用多方计算，或对输入使用更简单的阈值加密。但是，这种解决方案的部署成本会很高。在这篇远景论文中，我们主要关注使用值得信赖的**硬件**（因为它目前广泛可用）作为Glimmers执行隐私保护用户数据验证的实现平台。我们的工作回顾了使用安全计算元素作为客户-本地可信第三方[1]的早期设想，特别是在保护用户隐私的上下文中。

### 3 在SGX上的Glimmers

在今天的计算客户端上有几个可信硬件的常用实例，如英特尔TXT、AMD SVM、ARM  TrustZone和英特尔SGX。一般来说，所有这些平台都提供了一个硬件强制可信执行环境（TEE），它可以执行与任何漏洞或恶意代码隔离的功能。

在本文中，我们集中在实现Glimmers使用Intel的SGX[9]。SGX重新引发了人们对可信计算的兴趣，并在服务器端进行了大量使用[2,8,15]。**相反，我们正在研究如何将SGX用于客户端，以实现信任的微光**——注意，在撰写本文时，SGX仅在客户级CPU上可用。SGX提供了一种叫做**enclave的可信执行环境**（TEE）。除了隔离，SGX enclave还支持**远程证明**，这允许它以加密方式向远程方证明它在合法的enclave中正确运行。最后，它提供了**密封存储**，允许它对数据进行加密，这样，只有数据或其他指定的二进制文件在合法的enclave中运行，才能解密数据。SGX enclaves虽然非常强大，但它使用有限的资源运行，无法直接访问特权CPU操作（如IO），并且必须通过不受信任的主机操作系统来协调系统服务。因此，作为enclaves实现的Glimmers必须是简单的，并且大部分是孤立运行的。

<img src="C:\Users\Ree\AppData\Roaming\Typora\typora-user-images\1605932309973.png" alt="1605932309973" style="zoom:50%;" />

图3描述了基于SGX的Glimmer的设计。微光有三个主要组成部分。**验证组件**从客户机设备接收两种类型的输入:用户输入(将被发送到服务)和私有验证数据(微光内部使用这些数据来运行验证谓词)。在某些情况下，直接在验证谓词中使用用户贡献，而在其他情况下，则在那里使用独立的上下文私有信息。例如，在预测键盘服务中，模型参数将根据有效的权重范围[0,1]进行范围检查。相反，更具侵入性的验证谓词可以请求附加的数据，而不是提供给服务，比如单独的按键和计时，或者在用户触发的HTTP  GET请求中显示类类型数据的web浏览器日志，以验证用户的贡献。对于一个将地点的照片附加到地图上位置的应用程序，Glimmer可以请求验证信息，如精确的GPS位置和轨迹，相机硬件的指纹，以及访问设备上的其他照片来建立上下文。请注意，微光不能直接获得这样的信息;它必须从主机系统请求它。

**隐藏（Blinding）**是第二个Glimmers组成部分。它的目的是隐藏私有的、用户贡献的值，这样服务就可以计算它们的聚合，而不会显示单个贡献的数据。盲操作必须与验证一起执行，因为在盲操作发生后，验证是不可能的。为了说明这是如何工作的，我们给出一个简单的例子[4]。假设存在一个可信盲服务，该服务本身可以作为一个单独的enclave在一个客户机上实现，或者作为一个独立的可信服务来计算N个随机盲值$p_i$，使得
$$
\sum_{i=0}^{N-1}p_i=0
$$
然后，它将每个pi密封到Glimmer代码中，并将其中一个密封值加密到N个客户机的公钥中，将加密的盲值分发给在每个客户机上运行的Glimmers。每一个Glimmers的用户i都可以解密和解开它隐藏的值。然后盲组件计算盲用户的贡献yi=  xi+ pi。发送yi到服务是安全的，因为服务不能通过它计算私有的xi（因为盲值pi是秘密的）。然而，一旦服务将所有的yi聚合在一起，它可以计算出所有xi的准确的和：公式。回想一下，非私有用户的贡献不需要被隐藏；例如，在地图位置的众包照片中，用户贡献的照片是为了共享的，所以它们不需要被隐藏。

第三个Glimmer组件是**签名**，它接受用户提供的输入（隐藏或未隐藏的）和验证组件的结果，验证组件的结果可以是布尔型的“valid”/“invalid”，或者置信度值。如果验证通过，签名组件对用户提供的输入进行签名，并将其返回给客户机，以便传输给服务。为了关闭任何边通道，如果验证失败，微光仍然可以签署贡献，但贡献将包含一个表明它是无效的位，这应该只有服务能够解释。所使用的签名密钥可以由服务提供，并将其密封（使用SGX密封设施）到Glimmer代码，以便仅对Glimmer  enclave的实例可用。

最后一个要求是Glimmers让用户和服务都相信它是正确的，即它同时具有输入机密性和完整性属性。为了说服用户，我们设想由第三方（如EFF）进行审查和正式验证；而服务可以执行自己的审查和验证，以说服自己。一旦通过审查，Glimmer的散列就会发布，用户可以使用SGX来证明他们的客户正在运行经过批准的Glimmer。类似地，该服务可以确保对已批准的微光密封签名密钥。因为微光在它的外部交互中必然是小的和有限的，所以它可以接受没有运行时错误(如缓冲区和整数溢出)的正式验证[11,19]。此外，最近有很多研究致力于正式验证SGX  enclaves中秘密值的机密性[17,18]。程序员的负担相对较低：用相对简单的编程语言（例如，C）编程，使用相对简单的习惯用法（例如，有界循环，没有函数指针，等等），显式标记秘密输入，显式标记解密函数（例如，盲法和加密）。简单的功能性属性验证可以确定每个签名值都经过了验证，并且所有私有信息都被掩盖了。

我们在图3中显示了单个SGX  enclave中的所有组件，这更有效，因为只有一个转换进入和离开该enclave。但是，为了增加验证的便利性，可以对Glimmer进行分解，以便每个组件在自己的enclave中运行。当然，组件之间的通信现在也必须得到保护。

### 4 部署注意事项

在本节中，我们将考虑如何在具有挑战性的部署场景中应用Glimmer，或者使用敏感的验证谓词，或者当SGX在需要Glimmer功能的客户端设备上不可用时。

#### 4.1 验证保密性

到目前为止，我们已经描述了在将用户贡献用于共享服务的应用程序中使用Glimmers的情况。然而，Glimmers在隐私和信任不一致的其他问题上也有应用。例如，考虑web服务中检测bot的情况。虽然验证码是检测机器人的标准方法，但它们也有自己的缺点，比如对计算机视觉和验证码农场的漏洞，以及对合法人类用户的烦恼。另一种解决方案是在网页中嵌入一个JavaScript“检测器”，它能直观地检测是否有人(而不是机器人)存在。这样的解决方案收集大量的信号，比如客户端执行JavaScript的忠实程度，客户端系统软件和硬件的指纹，UI交互的时间和频率，比如鼠标的移动和焦点的变化[7,14]。这些信号被发送回web服务，web服务使用它们来确定发送者是机器人还是人。然而，这些信号通常包含私人信息，如用户的cookie、浏览历史和浏览兴趣[10]。Glimmer可以通过执行验证来保护个人隐私，验证需要访问客户机上本地的敏感信息，并且只向web服务发送1位信息——无论用户是否是人。

在这样一个敌对的示例中，web服务可能希望向对手隐藏确切的验证谓词，这是我们称为验证机密性的属性。Glimmers可以通过接受来自web服务的加密代码和数据，并在加密区内解密和运行这些代码，在那里纯文本代码不受硬件TEE的观察。

一个挑战是确保用于签名和加密代码和数据的密钥安全传输到Glimmer，并且Glimmer只接受来自合法web服务的密钥。这可以通过使用远程证明来实现，远程证明使数据，例如Diffie-Hellman（DH）握手值绑定到在enclave中运行的代码。这将向服务断言DH握手是合法的。类似地，Glimmer需要确保DH握手是与合法的服务一起发生的，这可以通过服务对其DH握手值进行签名并在Glimmer代码中嵌入签名验证密钥来完成。一旦与DH密钥交换协商共享秘密，秘密代码和数据就可以从服务安全地传输到Glimmer。

另一个挑战是，当Glimmer的一部分由于在运行时进行了加密和动态设置而不再被审计时，向用户证明输入的机密性。这可以通过将Glimmer和服务之间的消息格式公开，并让运行时审计员检查每个消息是否格式良好，并且只包含一个位的信息(即一个位加上定义良好的签名和质询响应)来实现。虽然这并不排除隐蔽通道，但它为此类通道的容量设置了一个硬性上限。

#### 4.2 微光即服务

到目前为止，我们建议Glimmers运行在客户端设备上。然而，考虑到物联网设备日益增长的趋势，可能会有一些设备为用户做出的贡献必须是可信的，但没有具有可信计算能力的处理器。在这种情况下，我们设想一个中立的——但不一定是可信的——第三方可能会提供代表客户运行Glimmer作为服务的能力。这第三方可能只是另一个设备属于同一用户(如机顶盒或家庭服务),当地的一群人,用户知道(如大学、社区或教堂),甚至是一个众所周知的实体愿意出售或提供资源来提高用户隐私。请注意，与受信任的第三方不同，Glimmer服务仍然依赖于SGX提供担保，在组织上不一定需要信任。

主要的标准是客户端设备需要确定它正在将其私有数据发送给真正的微光。幸运的是，可以使用上述建立安全通道的相同认证机制来实现这一点。认证使客户端能够确保安全通信通道的另一个端点位于已批准的Glimmer中。完成此工作后，客户机就可以传输用户贡献和私有数据，并作为回报接收已签名的(如果必要的话，是盲的)用户贡献，然后可以将其转发给服务。

### 5 挑战与未来工作

微光的有效性取决于用来决定用户贡献是否可信的验证谓词的有效性和实用性。如果没有到用户提供的数据的收集点的可信路径，验证函数必须能够抵抗数据伪造。因此，验证问题包括:a)检查多个不可信数据源的一致性，以检测伪造贡献的存在;b)对照描述典型可信贡献的模型检查贡献的数据。因此，验证的成功取决于谓词某些方面的机密性(即验证机密性):它收集的确切数据，或者它使用的验证模型。幸运的是，TEE被设计用来保护其所执行功能中间值的机密性和完整性;即便如此，那些很难或不可能通过观察其输入和输出来进行反向工程的功能，仍然是一个活跃的、开放的研究问题。我们对未来工作的一些初步想法包括:收集比模型需要的更多的验证数据，隐藏或随机干扰验证结果，混淆验证谓词本身。

此外，像SGX和Trustzone这样的Tees对它们支持的功能类型有限制;例如，SGX  enclaves只能调用用户空间ring-3指令。因此，它们不能直接对设备、设备驱动程序、缓冲区缓存、浏览器历史记录等的输入和输出进行系统级的观察。即使是在前几代人身上，这也一直是t恤的一个顽疾。虽然已经发布了一些关于建立可信路径的研究建议，但还没有普遍的解决方案。通过使用不太容易被篡改的外部观察(例如，通过中间人或可信的外部服务来观察和记录客户的行为)，可以部分地克服这个障碍。另一个很有前途的应用程序可能涉及一个性能相对较好但仅限于用户空间的TEE（例如，SGX enclave）与一个使用速度较慢但具有系统级能力的TEE（例如，通过Intel的TXT[19]启动的经验证的迷你hypervisor，或是一个延迟发布的TEE[13]）进行通信；后者可以收集值得信赖的系统观察结果，它可以定期进行验证，以便使用前者的频繁验证检查。

### 6 总结

我们提出了信任的微光，在可信的计算硬件上实现，可以在不损害用户隐私的情况下为服务提供用户贡献的数据的可信性保证。我们描述的设计使用英特尔SGX，我们目前正在实施。虽然以前关于SGX的许多提议都是用于服务器端[2,8,15]，或者提供主要的服务器端好处(即DRM、移动支付)，但我们认为Glimmers是客户端可信计算的首批应用之一，它可以使服务和用户都受益。